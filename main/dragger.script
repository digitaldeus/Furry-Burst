-- 720 x 1280

local camera = require "orthographic.camera"

local JOINT_ID = "dragger_joint"

local function remove_all_joints(self)
	for k in pairs(self.joints) do
		physics.destroy_joint(k, joint_id)
	end

	self.last_joint = go.get_id()
end

local function add_joint(self, message_id)
	local start_path = hash_to_hex(self.last_joint) .. "#collisionobject"
	local end_path = hash_to_hex(message_id) .. "#collisionobject"
	physics.create_joint(physics.JOINT_TYPE_SPRING, start_path, JOINT_ID, vmath.vector3(0), end_path, vmath.vector3(0), { max_length = 20 })
	self.last_joint = message_id
	self.joints[message_id] = true
end

function init(self)
	msg.post(".", "acquire_input_focus")

	self.camera = hash("/camera")
	self.dragging = false
	self.last_joint = go.get_id()
	self.joints = {}


	print(go.get_id())
	print(hash_to_hex(self.last_joint))
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		if not action.released then
			self.dragging = true
			local screen_coords = vmath.vector3( action.x, action.y, 0)
			local pos = camera.screen_to_world(self.camera, screen_coords)

			go.set_position(pos)
		else
			if self.dragging then
				self.dragging = false
				go.set_position(vmath.vector3(20000))

				remove_all_joints(self)
			end
		end
	end
end

function on_message(self, message_id, message)
	if message_id == hash("contact_point_response") then
		if not self.joints[message.other_id] then
			add_joint(self, message_id)
		end
	end
end

